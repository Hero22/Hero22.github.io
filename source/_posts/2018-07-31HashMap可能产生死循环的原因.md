---
title: 高并发下的HashMap
date: 2018-07-31 15:22:26
tags:
- java
---

HashMap本身不是线程安全的，所以高并发的情况下不应该使用HashMap，但是这里还是看了一下HashMap可能会产生的问题及其原因。

<!-- more -->

### 参考 
[https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html](https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html)


### 正常情况下HashMap
当HashMap中的元素超过其阀值时，HashMap要进行扩容，进行resize()操作

``` java
final Node<K,V>[] resize() {
   // ...省略长度的计算
    table = newTab;
	if (oldTab != null) {
		for (int j = 0; j < oldCap; ++j) {  // 遍历原HashMap，把每个Entry放到新的HashMap中
			Node<K,V> e;
			if ((e = oldTab[j]) != null) {
				oldTab[j] = null;
				if (e.next == null)
					newTab[e.hash & (newCap - 1)] = e;
				else if (e instanceof TreeNode)
					((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
				else { // preserve order
				  // ....
					Node<K,V> next;
					do {
						next = e.next;      // 
					  // ....计算Hash等操作
					} while ((e = next) != null);
				   //....
					}
				}
			}
		}
	}
	return newTab;
}
```
单线程下的resize()
![enter description here](https://image.zero22.top/images/2018-07-31/originalmap1.gif)
接下来进行resize()操作，首先e指向A，next指向B，然后把e放到新的HashMap中
![enter description here](https://image.zero22.top/images/2018-07-31/iteration1.gif)
结束这一次迭代时把e指向B
就这样循环的把每一个Entry都放到新的HashMap中
![enter description here](https://image.zero22.top/images/2018-07-31/iteration2.gif)
最终变成这样：
![enter description here](https://image.zero22.top/images/2018-07-31/iteration3.gif)
**注意while循环的结束条件为 e==null**

### 并发下的HashMap
假设有两个线程对上边的HashMap进行操作，在他们运行时，都知道要进行resize()，首先是线程1：
![enter description here](https://image.zero22.top/images/2018-07-31/e1next1.gif)
刚把e和next赋值，cpu就被线程2抢走了，而且线程2还比较厉害，一直把resize()完成才退出，那么线程2结束时我们的HashMap就变成这样了：
![enter description here](https://image.zero22.top/images/2018-07-31/thread2done.gif)
**这里线程2对HashMap的操作会影响线程1中的e和next**
然后线程1继续执行，但是他不知道e和next的位置已经发生了变化，甚至不知道他已经不用再resize()了，需要注意的是，在resize()过程中，新表在建立过程中会把旧表中的Entry都置为null，所以线程1中的e和next根本并没有变化，这是e和next所指向的内存中的数据中的信息被线程2在创建新表过程中改变了(该信息即指他们相对的位置)

然后线程1在线程2建立的新表的基础上继续resize()，要注意的是，此时线程1在循环之前就把他的新表建立了，线程1继续执行的效果如下
![enter description here](https://image.zero22.top/images/2018-07-31/thread1-2.gif)
把A取出放入新表中，然后e指向next即B，注意此时B的next为A，然后新一轮迭代中

``` java
 next = e.next
```
所以next指向了A
![enter description here](https://image.zero22.top/images/2018-07-31/thread1-3.gif)

下一轮迭代中，e指向next即A，next指向null，然后用头插法把A插到头，结果就变成这样了！！
![enter description here](https://image.zero22.top/images/2018-07-31/thread1-4.gif)

虽然建表的过程就此结束了，但是新表中含有了环！！那么下次只要有查询的需求并且查到了这个环，那么就会一直查下去造成死循环！

### 问题
说起来是这个道理，但是在看源码时还是有一些疑问：

 1. 每变量一个旧表中的Entry就把他置null，那么对其他的线程没有影响吗
 2. 关于线程1中的e和next，为什么在线程2完成resize()后，e和next就指到了新表中的元素

想要搞清楚一个问题还真是不简单，后边还要更新。

