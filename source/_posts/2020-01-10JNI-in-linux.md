---
title: JNI in linux
date: 2020-01-10 11:58:41
tags: JNI
---

在复习`JVM`时又看到了本地方法栈, 那么本地方法是个什么方法呢。`JNI`即`java native interface`, 通过这个东西可以实现在`Java`中调用其他编程语言实现的功能，在和系统底层交互时`Java`大都通过`JNI`调用`C/C++`来实现的。

<!--more-->

下面用个实例来说明本地方法是如何实现的。

### 环境

`jdk-11.0.5`: 在10之后就看不到`javap`这个命令了，这个命令的主要功能是根据`java`源码中声明的`native`方法，生成对应的`c/c++`头文件，其中的主要内容就是对`native`方法的声明。现在这个功能集成到了`javac`下，使用`javac -h target_dic src_dic`

`centos7`: 在后续的编译过程中需要用到`gcc`, `gcc-c++`等包

### 具体实现

#### 1. java源码

首先写一点简单的`java`源码，其中包含一`native`方法就行：

``` java
public class HelloJni {

  static {
    System.loadLibrary("HelloJni");
  }

  public static native void sayHello();

  public static void main(String args[]) {
    sayHello();
  }
}
```

#### 2. 生成头文件

使用命令`javac -h HelloJni.java`, 得到的头文件如下：

``` C++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include "jni.h"
/* Header for class HelloJni */

#ifndef _Included_HelloJni
#define _Included_HelloJni
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloJni
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloJni_sayHello
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```
可以看到这里自动生成的头文件中需要`jni.h`, 在`jni.h`中又需要`jni_md.h`。

#### 3. C++实现

对头文件中方法进行实现，我用的`c++`，不晓得头文件中的`_cplusplus`是不是在暗示用`c++`。

``` C++
#include "stdio.h"
#include "HelloJni.h"

JNIEXPORT void JNICALL Java_HelloJni_sayHello
  (JNIEnv *, jclass)
{
  printf("Hello World By Jni\n");
}
```

#### 4. 编译

我觉得比较绕的地方就是编译的过程了。

首先进行预处理，编译，汇编过程，不搞链接：

``` s
gcc -I/root/jdk-11.0.5/include 
    -I/root/jdk-11.0.5/include/linux -fPIC -c HelloJni.cpp
```

`-Idir`: Add the directory dir to the list of directories to be searched for header files.
前边提到的`jni.h`在`include`目录下，`jni_md.h`在目录`include/linux`目录下。

`-fPIC`: 当编译的时候不用这个指令的话，在后边生成动态库会出问题：


    /usr/bin/ld: HelloJni.o: relocation R_X86_64_32 against .rodata can not be used when making a shared object; recompile with -fPIC
    /usr/bin/ld: final link failed: Nonrepresentable section on output


编译好后得到`HelloJni.o`文件，做进一步处理：

```s
gcc -shared -o libHelloJni.so HelloJni.o
```
就能得到`linux`下动态链接库文件`libHelloJni.so`，这个文件在生成时需要规定其名字，由于在`java`代码中指定的加载库名为`HelloJni`，在生成链接库文件时需要命名为`libHelloJni.so`，否则会找不到库文件。

  Exception in thread "main" java.lang.UnsatisfiedLinkError: no HelloJni in java.library.path: [/root/test, ., /usr/java/packages/lib, /usr/lib64, /lib64, /lib, /usr/lib]

#### 5. 运行

如果直接运行，还是会报错，

    Exception in thread "main" java.lang.UnsatisfiedLinkError: no HelloJni in java.library.path: [/usr/java/packages/lib, /usr/lib64, /lib64, /lib, /usr/lib]

会发现我们得到的链接文件不在后边的`path`中，可以选择把得到的链接文件拷一份，或者使用命令:

```s
export LD_LIBRARY_PATH=`pwd`:$LD_LIBRARY_PATH
```

把当前目录加到`path`中，这个变量应该是运行时生成的还是怎样，直接在`linux`中查看该变量啥也没有。

最后直接运行`java`代码，当然首先要`javac`。

![](https://image.zero22.top/jni/jni.png)
