---
title: TreeMap
date: 2018-08-20 15:51:37
tags:
- java
---

我们知道，map中的元素是由键值对组成的，TreeMap就是把这些键值对通过某个因素连接组成树的一种数据结构。后边说的都是jdk1.8版本的。其中TreeMap中的树是红黑树，在构造TreeMap对象时，可以选择传入一个比较器Comparator，如果没传的话，那么TreeMap中元素的key需要实现Comparable接口，这个规定是强制的，不然会有异常。下面看看常用的方法，说是常用我却没用过。

<!--more-->

### put

``` java
public V put(K key, V value) {
  Entry<K,V> t = root;
  if (t == null) {
    compare(key, key); // type (and possibly null) check

    root = new Entry<>(key, value, null);
    size = 1;
    modCount++;
    return null;
  }
  int cmp;
  Entry<K,V> parent;
  // split comparator and comparable paths
  Comparator<? super K> cpr = comparator;
  if (cpr != null) {
    do {
      parent = t;
      cmp = cpr.compare(key, t.key);
      if (cmp < 0)
        t = t.left;
      else if (cmp > 0)
        t = t.right;
      else
        return t.setValue(value);
    } while (t != null);
  }
  else {
    if (key == null)
      throw new NullPointerException();
    @SuppressWarnings("unchecked")
      Comparable<? super K> k = (Comparable<? super K>) key;
    do {
      parent = t;
      cmp = k.compareTo(t.key);
      if (cmp < 0)
        t = t.left;
      else if (cmp > 0)
        t = t.right;
      else
        return t.setValue(value);
    } while (t != null);
  }
  Entry<K,V> e = new Entry<>(key, value, parent);
  if (cmp < 0)
    parent.left = e;
  else
    parent.right = e;
  fixAfterInsertion(e);
  size++;
  modCount++;
  return null;
}
```

不是很难，如果树为空，就新建root；否则根据Comparator/Comparable比较key值，如果key值已经存在了，直接用新value覆盖之；不然就找到插入点进行插入，最后作调整。
TreeMap的作者也参与了HashMap的编写，但是其中红黑树调整的写法却不一样。

### getEntry

这里就写个最简单的get方法吧，里边还有各种get方法，比如模糊查找，找比特定值大的部分中的最小的，或者比特定值小的部分中最大的等等，

``` java
final Entry<K,V> getEntry(Object key) {
  // Offload comparator-based version for sake of performance
  if (comparator != null)
    return getEntryUsingComparator(key);
  if (key == null)
    throw new NullPointerException();
  @SuppressWarnings("unchecked")
    Comparable<? super K> k = (Comparable<? super K>) key;
  Entry<K,V> p = root;
  while (p != null) {
    int cmp = k.compareTo(p.key);
    if (cmp < 0)
      p = p.left;
    else if (cmp > 0)
      p = p.right;
    else
      return p;
  }
  return null;
}
```

按照Comparator或者Comparable来查找指定的key。

### over
