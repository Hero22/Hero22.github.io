---
title: LeetCode 32. Longest Valid Parentheses
date: 2020-10-31 10:38:24
tags:
- leetcode
- dp
- 栈
- 妙
- 我怎么想不到
---

在只包含`(`and`)`的字符串中找最长有效括号串的长度

<!--more-->

### dp

dp[i]表示从头到第i位的有效括号长度，注意这里要包含从0到i的每一位，那么也就是说，当第i位是`(`时，其有效长度总是0，因为没有和第i个`(`相匹配的。剩下的就是第i位为`)`时的判断，此时其有效长度可分为两部分计算：

#### part1

第一部分为包含当前第i个`)`的片段的有效长度，此时就要找到和这个`)`匹配的位置是否是`(`，那么如何找到和这个右括号相匹配的位置呢？

![fig1](fig1.png)

通过观察上图，可以发现其对应位置坐标为 i-dp[i-1]-1，其中dp[i-1]表示第i个`)`前边的有效长度，那么其对应位置和i之间就隔了这么远，因此能得到上述对应的坐标，此时可以判断这个地方是不是`(`，是的话，`dp[i]=dp[i-1]+2`，这就是第一部分

#### part2

第二部分就是，抛去包含i的这一段的有效长度，看剩下的位置的有效长度能否和这一段接上，那么如何找到剩下的这一部分呢，很简单，因为之前dp[i]定义的就是正好到i这一位置的有效长度，那么前一段的末尾的坐标就是`i-dp[i-1]-2`, 比如下图：

![fig2](fig2.png)

然后`dp[i] += dp[i-dp[i-1]-2]`就行了

#### code

```java
class Solution {
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int max = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                dp[i] = 0;
            } else if (i > 0) {
                // 找到对应位置，part1
                if (i - dp[i - 1] - 1 >= 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + 2;
                    // 再试着接头，part2
                    if (i - dp[i - 1] - 2 >= 0) {
                        dp[i] += dp[i - dp[i - 1] - 2];
                    }
                }
            }
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}
```

### 栈

栈的方式比较巧妙，栈不是用来存储元素的，而是用来存储元素的坐标的。

如果是`(`，无脑入栈其坐标；如果是`)`，先把栈顶出出来，有两种可能，如果栈不为空则出的是`(`，因为栈底保存了一个最新遇到的不会被匹配的`)`，此时的有效长度就为`i-栈顶元素的坐标`；如果栈为空，说明把那个不匹配的`)`给出了，则当前遇到的`)`就作为最新遇到的不会被匹配的`)`入栈。

确保栈底放的是最后一个不匹配的`)`的坐标，相当于**重置**的功能，利用上边dp的说法，就是该`)`的后部分不会和`)`的前部分**接头了**

#### code

```java
class Solution {
    public int longestValidParentheses(String s) {
        Deque<Integer> stack = new LinkedList<>();
        stack.push(-1);
        int max = 0;
        for(int i = 0; i < s.length(); i ++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            }
            else {
                if (!stack.isEmpty()) {
                    stack.pop();
                    if (stack.isEmpty()) {
                        stack.push(i);
                    }
                    else {
                        max = Math.max(i-stack.peek(), max);
                    }
                }
            }
        }
        return max;
    }
}
```

### 计数判断

如果只是判断字符串是否为有效的括号对时，只用比较遇到的左括号的数量是否会一直大于等于右括号的数量，其长度就为有效的左括号或右括号的两倍。

从左到右遍历时，如果右括号的数量等于左括号的数量时，说明此时是有效片段，且长度为左括号数的两倍；如果右括号数大于左括号数，说明此时的右括号不会再匹配到了，进行**重置**，即将左右括号计数归0，和用栈时栈底的`)`类似。

但是这样遍历一遍是不够的，存在左括号一直大于右括号的情况，这样就没法到达计算有效长度的逻辑了，因此还要再从右往左遍历一遍。

### 小结

用时: dp<计数<栈，空间: 计数<dp，栈

