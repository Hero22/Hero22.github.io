---
title: LeetCode 1024. Video Stitching
date: 2020-10-25 17:38:39
tags: 
- leetcode
- 贪心
- dp
- 青蛙跳
---

给定一些区间，从中选择某些区间（可重叠），使得其能完全覆盖`[0, T]`，返回最少需要的区间个数。

<!--more-->

看到这一题想到了编程之美上的区间重合问题，又想一下发现求解是不同的，一个是简单的判断能否完全覆盖，一个需要最少区间的区间个数去覆盖。由于见识比较少，就想着按书上的思路来，先做个排序再说，这样一来，区间片段就按开始从小到大排序，当开始相同时，就忽略掉前边的区间，因为后边的总能把前边的区间完全覆盖掉，因此只考虑相同起始点的最后一个区间。然后挨着盘的看后边的区间能否**延长**当前已覆盖的区间，如果能延长的话，就把需要的区间数+1，但是这样是存在问题的，比如下边的情况，要覆盖的总区间为`[0, 9]`

![fig1](fig1.png)

这样的情况，在上边的简单的判断逻辑情况下，会发现每个区间都能**延长**前边的区间们所覆盖的区间，这样一来要覆盖完全就需要上边的所有4个区间，但其实只用3个区间就行（0-4,4-8,6-9||0-4,2-6,6-9），后来又经过长时间的冥思苦想，发现可以这样做，首先0开头的肯定是要选的，比如是[0, a]，那么后边的就可以选从[1, a]之间，能覆盖的最远的区间（看了解答后才想起来是青蛙跳）。

但是提交后，发现效率很低，那肯定是排序的影响，其实也确实是不用排序的，只需要提前处理一遍，把[0, T]之间开头的能到的最远的区间记录下来，剩下的步骤其实和上边是一样的。
