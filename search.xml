<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LINUX删除查找到的所有文件及目录]]></title>
    <url>%2F2018%2F07%2F08%2F2018-07-08-11-37-13%2F</url>
    <content type="text"><![CDATA[这里需要用find命令，因为find命令后边可以跟其他可执行的命令 Step1. 首先根据关键字查找特定的文件及目录我这里用steam作示范，这样就能找到所有包含’steam’关键字的文件及目录 Step2. 在后边追加操作命令1) 追加命令格式为: -exec command {} \;在{}和\之间必须要有空格，否则会报错. 2) xargs用于从 标准输入获得参数并且传递给后面的命令，这里使用的命令是 rm，然后由rm删除前面选择的文件]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法中求NEXT时回溯?]]></title>
    <url>%2F2018%2F06%2F30%2F2018-06-30-21-32-58%2F</url>
    <content type="text"><![CDATA[在网上看ＫＭＰ算法相关的博客时，在求next数组时基本上都会有这么一句: k = next[k-1] 或者 k = next[k] 该赋值语句在判断 当前字符 不等于 当前字符的前一个字符的相同前缀的 后一个字符时 用到， 用语言来描述不太方便，画图试试 真的是太神奇了，使用k = next[k-1] 或 k=next[k]，就可以保证用最快方式找到应该和 “d” 进行比较的位置，丝毫不拖泥带水，我只能说太巧妙了。 像上边这个串，第二次比较后还是不一样，那么k就等于-1，退出循环，说明再往前找就找不到和 ”d” 前边一样的前缀了，所以 ”d” 下边也是-1，即没有匹配的前后缀。 这个玩意我断断续续想了两天，突然就懂了一些，不得不说”看毛片”还是难啊。]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA之ERROR/EXCEPTION]]></title>
    <url>%2F2018%2F06%2F24%2F2018-06-24-23-24-09%2F</url>
    <content type="text"><![CDATA[java异常分为Error和Exception，二者都是继承自Throwable 先来看看Exception： The class Exception and its subclasses are a form of Throwable thatindicates conditions that a reasonable application might want tocatch. The class Exception and any subclasses that are not also subclasses ofRuntimeException are checked exceptions. Checked exceptions need to bedeclared in a method or constructor’s throws clause if they can bethrown by the execution of the method or constructor and propagateoutside the method or constructor boundary. 可以知道Exception的子类除了RuntimeException 都是检查型异常，在程序中需要捕获处理或者抛给上层处理。 再看看RuntimeException RuntimeException is the superclass of those exceptions that can bethrown during the normal operation of the Java Virtual Machine. RuntimeException and its subclasses are unchecked exceptions.Unchecked exceptions do not need to be declared in a method orconstructor’s throws clause if they can be thrown by the execution ofthe method or constructor and propagate outside the method orconstructor boundary. 可以看到不要求在编译的时候处理。 Error的定义 An Error is a subclass of Throwable that indicates serious problemsthat a reasonable application should not try to catch. Most sucherrors are abnormal conditions. The ThreadDeath error, though a“normal” condition, is also a subclass of Error because mostapplications should not try to catch it. A method is not required to declare in its throws clause anysubclasses of Error that might be thrown during the execution of themethod but not caught, since these errors are abnormal conditions thatshould never occur. That is, Error and its subclasses are regarded asunchecked exceptions for the purposes of compile-time checking ofexceptions. Error是程序中严重的错误，任何合理的程序都不能去捕获Error。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NETSTAT 命令]]></title>
    <url>%2F2018%2F06%2F22%2F2018-06-22-11-20-01%2F</url>
    <content type="text"><![CDATA[Print network connections, routing tables, interface statistics,masquerade connections, and multicast memberships netstat用来显示网络相关的信息，如网络连接，路由表，接口统计，伪装链接和广播成员 常用的几个选项 –numeric , -n Show numerical addresses instead of trying to determinesymbolic host,port or user names. 不解析名称，显示数字就行 -p, –program Show the PID and name of the program to which each socket belongs. 显示端口(?)所属的程序的pid和名字 -l, –listening Show only listening sockets. (These are omitted by default.) 只显示正在监听的端口 {-t|–tcp} {-u|–udp} 分别表示显示TCP/UDP传输协议的连接 一些在我看来很高级的用法：查看连接某服务端口最多的的IP地址： netstat -ntu | grep :80 | awk ‘{print $5}’ | cut -d: -f1 | awk‘{++ip[$1]} END {for(i in ip) print ip[i],”\t”,i}’ | sort -nr TCP各种状态列表： netstat -nt | grep -e 127.0.0.1 -e 0.0.0.0 -e ::: -v | awk ‘/^tcp/{++state[$NF]} END {for(i in state) print i,”\t”,state[i]}’ 查看phpcgi进程数，如果接近预设值，说明不够用，需要增加： netstat -anpo | grep “php-cgi” | wc -l]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA编辑POM文件时没有提示]]></title>
    <url>%2F2018%2F06%2F21%2F2018-06-21-16-15-21%2F</url>
    <content type="text"><![CDATA[这需要我们更新IDEA中maven 的repositories 如下图： 选中本地仓库点击右边的更新，这样再编辑pom文件时就会提示你本地仓库中所含有的坐标]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT CLONE BRANCH]]></title>
    <url>%2F2018%2F06%2F20%2F2018-06-20-22-09-50%2F</url>
    <content type="text"><![CDATA[在使用git clone项目后，查看本地分支，只有master分支，远程仓库的其他分支并没有克隆下来，如果需要其他分支可以用下面两种方法 方法一git branch -a 先查看当前远端分支情况 git checkout origin/xxx 选择远端xxx分支 git branch xxx 创建本地xxx分支 git checkout xxx 选择新创建的分支就可以了 方法二git clone -b]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TRY REDIS中的命令]]></title>
    <url>%2F2018%2F06%2F12%2F2018-06-12-21-02-16%2F</url>
    <content type="text"><![CDATA[中文官方网站对其的介绍： Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets）与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRUeviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 GET/SET Redis is what is called a key-value store, often referred to as aNoSQL database. The essence of a key-value store is the ability tostore some data, called a value, inside a key. This data can later beretrieved only if we know the exact key used to store it. We can usethe command SET to store the value “fido” at key “server:name” 用 SET 对key进行赋值用 GET 获取key的value. DEL Other common operations provided by key-value stores are DEL to deletea given key and associated value, SET-if-not-exists (called SETNX onRedis) that sets a key only if it does not already exist, and INCR toatomically increment a number stored at a given key 用DEL 删除一个变量后，查询该变量变为 nil，意思为”空，零”INCR在Redis中为自加1操作，为原子性的操作. LIVE TIME Redis can be told that a key should only exist for a certain length oftime. This is accomplished with the EXPIRE and TTL commands. 用EXPIRE 规定key的存在时长，单位为秒(默认)用TTL查看key还剩多久删除 The -2 for the TTL of the key means that the key does not exist (anymore). A -1 for the TTL of the key means that it will never expire. Note that if you SET a key, its TTLwill be reset. LIST Redis also supports several more complex data structures. The firstone we’ll look at is a list. A list is a series of ordered values.Some of the important commands for interacting with lists are RPUSH,LPUSH, LLEN, LRANGE, LPOP, and RPOP. You can immediately begin workingwith a key as a list, as long as it doesn’t already exist as adifferent type. RPUSH：放在list的右边LLEN：list的长度LRANGE：显示从start到end的数据LPOP：删除最左边的元素 SET The next data structure that we’ll look at is a set. A set is similarto a list, except it does not have a specific order and each elementmay only appear once. Some of the important commands in working withsets are SADD, SREM, SISMEMBER, SMEMBERS and SUNION. SADD：添加元素SREM：移除元素SISMEMBER：判断set是否包含某一元素SMEMBERS：打印set内容SUNION：合并打印多个set SORTED SETS Sets are a very handy data type, but as they are unsorted they don’twork well for a number of problems. This is why Redis 1.2 introducedSorted Sets. A sorted set is similar to a regular set, but now each value has anassociated score. This score is used to sort the elements in the set. 可以通过设定的score进行排序的setZADD：添加元素 (exp. ZADD hackers 1940 “Alan Kay”)ZRANGE：升序ZREVRANGE：降序 HASHESHashes：用来存放对象很好HSET：存放对象属性和值 (HSET user:1000 name “John Smith”)HGETALL：获取对象的所有属性和值HGET：获取对象某个属性的值HINCRBY：指定对象某个数字属性的值加上HDEL：删除对象某个属性]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX下的JOB, FG, BG, &]]></title>
    <url>%2F2018%2F06%2F12%2F2018-06-12-19-59-58%2F</url>
    <content type="text"><![CDATA[在使用linux过程中，偶尔会不自觉的按ctrl + z，这时候会显示[1]+ Stopped 之类的，而且如果这时候你在做一些操作，比如编辑文件等，会直接回到命令状态。那么之前的工作去哪了呢? 去了Stopped于后台中了。 这是输入jobs命令，就可以查看Linux中的任务列表及任务状态，包括后台运行的任务。 bg(background) 将后台暂停的任务启动，在后台继续运行 fg(foreground) 将后台任务调至前台执行 &amp; 放在命令的最后，用于将任务放在后台执行]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git push]]></title>
    <url>%2F2018%2F05%2F24%2F2018-05-24-10-44-57%2F</url>
    <content type="text"><![CDATA[现在的情况是，本地有两个分支：master、div， 远程仓库有一个分支：master，本地master分支和远程master分支建立有跟踪联系，这样本地master分支提交时直接git push(只有一个远程仓库的情况下) 那么div分支也想提交到远程master怎么办呢，先试试直接git push：提示信息很清楚了 这里使用命令 git push origin HEAD:master 即可 而HEAD指向的是当前的分支，git可以通过HEAD找到当前的分支名，所以该命令相当于 git push origin div:master ==git push/pull &lt;远程主机名&gt; &lt;源分支&gt;:&lt;目的分支&gt;== 是git push常用的精简命令的完整格式，当然还可以加git push的各种 []，这里就不说了。 说实话，我平时只顾着用git push ，连git push不省略的格式是什么都不记得了，唉. 2018.06.20 更新 在推送前，我们可以使用命令 git push -u &lt;远程主机名&gt; &lt;分支名&gt; 其中-u 参数效果：如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push. –set-upstream 是用来和远程分支建立追踪关系]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX下配置环境变量]]></title>
    <url>%2F2018%2F05%2F21%2F2018-05-21-10-37-48%2F</url>
    <content type="text"><![CDATA[有些东西不自己写一下，总是会忘记，当然写了也可能还是会忘，但是找起来印象会深一点吧。之前在需要配置环境变量的时候就直接查了一下，完成配置后就没管了，最近再次想到这个问题，结果已经忘记该怎么配置了。所以什么东西都是写一下比较好吧. 方式一：使用export使用export命令直接修改PATH变量 方式二：修改/etc/profile 如果要立即生效需要执行命令 source /etc/profile 使用这种方式，所有用户都会受影响,当第一个用户登录时,该文件被执行. 类似的还有/etc/enviroment文件，影响所有用户 方式三：修改~/.bashrc 同样立即生效需要： source ~/.bashrc 专属于个人bash shell的信息，当该用户登录时以及每次打开新的shell时,该文件被读取. 类似的还有~/.profile，当用户登录时,该文件仅仅执行一次!默认情况下,它设置一些环境变量,然后执行用户的.bashrc文件.]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spirng(4)]]></title>
    <url>%2F2018%2F05%2F12%2F2018-05-12-10-33-42%2F</url>
    <content type="text"><![CDATA[第四章 IoC容器4.1 概述4.1.1 Ioc概述IoC全程 Inverse of Control(控制反转)，是Spring容器的内核，AOP，声明式事务等功能就在此基础上进行扩展。其包括两方面的内容： 一. 控制 二. 反转 对于我们编写代码来说，就是某一接口的具体实现类的选择控制权从调用类中移除，转交给第三方决定，即由Spring容器借由Bean配置来进行控制。 4.1.2 IoC的类型三种：构造函数注入，属性注入，接口注入，一般就用前两种 4.2. 相关Java基础知识Bean配置文件的功能实现用到了java的反射机制。 类加载器ClassLoader类加载器：寻找类的字节码文件并构造出类在JVM内部表示对象的组件。 在java中，一般分为三步： (1) 装载：查找和导入class文件 (2) 链接：执行校验，准备和解析步骤 校验：检查载入class文件数据的正确性 准备：给类的静态变量分配存储空间 解析：将符号引用转换成直接引用 (3) 初始化：对类的静态变量，静态代码块执行初始化操作 JVM的三个ClassLoader：根装载器，ExtClassLoader，AppClassLoader JVM装载类时使用“全盘负责委托机制”，“委托机制”是指先委托父装载器寻找目标类 4.3 资源访问利器4.3.1 资源抽象接口Spring设计了一个Resource接口，为应用提供更强的底层资源访问能力 4.3.2 资源加载为了避免加载不同的资源需要显示的使用不同的Resource实现类的麻烦，有了下边的 （1） 资源地址表达式 （2） 资源加载器 4.4 BeanFactory和ApplicationContext一般称BeanFactory为Ioc容器，称ApplicationContext为应用上下文或Spring容器 4.5 Bean的生命周期后边几点内容太多了，而且我并没有都理解，大多是介绍类继承体系等，这里就先不敲了。]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPRING(3)]]></title>
    <url>%2F2018%2F05%2F05%2F2018-05-05-10-17-29%2F</url>
    <content type="text"><![CDATA[Spring Boot示例3.1 安装配置maven，gradle，spring boot cli 选择其中一个就可以，官方推荐Maven和Gradle. 和一般的使用Spring配置大同小异，只不过Spring Boot把一些可能会一起用到的包封装起来，这样我们在写pom就不用写太多的配置。 代码包结构和spring(2) 中的类似，不过这里要加一个Application类位于com.wzx主包下，因为这个类是一个启动类，在这个类中要在类级别上标注@SpringBootApplication，可以代替@Configuration, @ComponentScan, @EnableAutoConfiguration这三个注解。 3.2 持久层3.2.1 使用Boot提供的JDBC启动器在模块pom.xml文件中导入spring-boot-starter-data-jdbc依赖及访问数据库的JDBC驱动器。 导入依赖后，为了让Spring Boot能自动装配数据源的链接，需要在资源根目录下创建一个application.properties，配置数据库的连接信息。想来应该会有模板，不然太多名字了。 接下来编写Dao类，和前面的没差。要注意的是，这里写完Dao后，不需要在Spring容器中进行配置，也就是不用管Dao类中的JdbcTemplate从哪来，Spring Boot会自己搞。 3.3 业务层业务逻辑和spring(2)一样，启用事务的方式不一样。 在spring(2)中，我们是在spring中使用AOP完成Service的配置，启动事务。 在这里，我们只需要在主类即Application类中加上@EnableTransactionManagement 注解，然后在业务类中需要事务的方法上标注@Transactional注解。 3.4 展现层3.4.1 配置pom.xml依赖和spring(2)没差，不过这里提到了如何正常使用JSTL标签，添加了依赖包 &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; 3.4.2 配置Spring MVC框架Application类继承SpringBootServletInitializer，重写configure方法。 3.4.3 处理登录请求编写Controller类 在application.properties中配置创建好的视图的路径，spring(2)是在spring MVC对应的配置文件中进行配置的，就是添加前缀后缀的那个 要注意的是使用Spring Boot，控制器中只能返回ModelAndView，记得在Spring中还能返回字符串，也能自动解析的。 3.5 运维支持添加依赖actuator，配置application.properties Source Codehttps://github.com/Hero22/spring3]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPRING(2)]]></title>
    <url>%2F2018%2F05%2F04%2F2018-05-04-19-02-44%2F</url>
    <content type="text"><![CDATA[第二章 快速入门在第二章中，主要讲解了Spring在项目中的一般应用，用到了Spring+Spring JDBC+Spring MVC.这里用的都是Spring提供的相关组件，所以DAO层用的这个. 2.1 实例概述这个实例的功能如下：用户进行登录，登录成功提示相应的信息; 登录失败提示信息。实现如下图： 2.2 环境准备2.2.1 构建工具MavenMaven简单来说就是一个管理项目中所需要的包的工具，如果不用Maven，那么项目中需要的包都需要我们自己下载然后放到项目中去，在自己一个人玩的时候没多大问题，但是在一个团队中，一个项目总是需要不止一个人吧，这时候成员在各自去下载需要的包，就可能会造成项目合并时用到的包的版本不一样什么的问题; 如果用Maven，那么成员就不需要去管理这些包了，通过一个配置文件，所有成员的包都统一了。(ps：以上只是我猜的，我并没有团队开发的经验，所以这也是我刚开始接触Maven) 下载Maven包后，需要配置M2_HOME环境变量，当然使用maven的前提是安装了jdk 在～/.profile或者~/.bashrc修改增加环境变量 ，按照下图方式配置环境变量注意”:” 相当于分隔符 2.2.2 创建数据库本例中涉及到两个表，用户表和登录信息表，分别存储用户的信息和用户登录的日志信息. 2.2.3 建立工程选择新建Maven项目，之后会产生一个pom.xml文件，用来配置包信息，配置文件我直接用的书中给的，想来在一个团队中的话，这个文件应该也是有专人书写直接用吧。另外注意到配置文件中有jetty插件，其实是一个Web应用服务器插件，用来运行web项目. 2.2.4 类包及Spring配置文件规划类包结构如下图：Spring配置文件在上图中可以看到有两个，其中smart-context.xml是主要的一个，另外一个是web.xml中配置的servlet所需要的. 2.3 持久层简单理解，持久层就是和数据库进行直接的数据交互的对象，把程序中的对象，例如本例的用户，持久化到数据库中，其实就是在数据库中插入一条用户数据. 2.3.1 建立领域对象由于该示例比较简单，PO/DO/VO(持久层/服务层/展现层)没什么区别，就直接复用了.建立两个领域对象: User，LoginLog. 2.3.2 DAO (数据访问对象是一个面向对象的数据库接口)两个领域对象分别对应一个DAO，在这里进行数据库的操作，用的是Spring JDBC. 2.3.3 在Spring中配置DAO主要定义JdbcTemplate及其需要的DataSource. 2.4 业务层业务层以下层的持久层为基础，为上层控制层提供服务，简单说来，就是把持久层再次包装，实现更加具体的功能，为控制层所用. 2.4.1 UserService这里只用一个业务对象UserService，用来实现用户登录时的匹配查找，以及登录成功后相关的更新信息操作. 2.4.2 在Spring中装配Service“事务管理的代码虽然无需出现在程序代码中，但我们必须以某种方式告诉Spring那些业务需要工作在事务环境下以及事务的规则等，以便Spring根据这些信息自动为目标业务添加事务管理的功能。” 也就是说，业务相关的操作需要在事务的环境下，这样操作更加安全。 这里涉及到了AOP相关的知识，我还不是很了解，后边再深入学习。 2.4.3 单元测试这里测试用到的是TestNG，和JUnit在使用中不清楚有什么区别。要注意的是，在使用”assertXXX()”方法时，要引入 org.testng.Assert.*这个静态包，我在用的时候IDEA不会提示我引入，需要自己手动引入该静态包。 2.5 展现层2.5.1 配置Spring MVC框架这里会用到Spring MVC，首先要对web.xml文件进行配置，来启动Spring容器。需要添加Spring配置文件的地址;添加Spring MVC的地址映射，就是配置一个servlet 2.5.2 处理登录请求POJO控制器类，用来控制页面的跳转，需要在spring-mvc.xml文件中进行配置 2.5.3 JSP视图页面写一个登录页面和成功页面. ##Source code https://github.com/Hero22/spring2 小结写的很简单，把大致的过程浏览了一遍，其中还有很多不懂的地方，比如说Spring容器，SpringMVC容器是什么东西，注解的应用等等，后面还要加油啊啊啊啊啊啊.]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA学习SPRING时的问题]]></title>
    <url>%2F2018%2F05%2F03%2F2018-05-03-08-51-10%2F</url>
    <content type="text"><![CDATA[1. 在IDEA中使用jstl书中没有提到这一点，但是我在使用时确实有问题，IDEA无法识别jstl的那个uri 方案1手动下载jstl，然后在IDEA的设置中找到在External Schemas and DTDs中添加，输入jstl的uri和刚刚下载文件中的tld中的c.tld，如下图： 方案2使用Maven构建项目时，直接导入需要的标签依赖 &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 2. 关于Spring中资源地址在使用Spring过程中，难免会要加载各种资源，一般会用到资源地址表达式，Spring支持classpath:，file:，http://ftp://，等，我在做实验时一般用到的是classpath:，但是对于这个路径到底在哪里却不是很清楚，我用的是IDEA，工程结构大概是这样的：在main下的java和resources都是classpath可以访问到的资源，因为这些文件在编译运行都会在target-&gt;classes中生成相应的内容.]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记本安装SSD, 并在SSD中安装系统]]></title>
    <url>%2F2018%2F05%2F02%2F2018-05-02-08-49-01%2F</url>
    <content type="text"><![CDATA[前言很早就想买个ssd了，经过一些事情之后，我也没那么多顾虑，想买就买了。本来打算是在ssd中重装一个系统的，但是后来考虑到电脑里边有些东西重装系统后再搞很麻烦，就没有选择重装系统了，但是突然想试试Linux，就选了Ubuntu，安在了ssd里边，把电脑搞成双系统，所以这篇文章有这几个部分吧：笔记本安装ssd、安装Ubuntu系统、笔记本实现双系统。 笔记本装ssd我的笔记本没有空出的位置装ssd，所以就把光驱拆了，买ssd时候把电脑型号发给客服，客服会告诉你用什么规格的支架。然后就是拆光驱，把ssd放进支架里，在把支架安在原来放光驱的地方，挺简单的。 对了，还有关于笔记本是否能发挥ssd性能的几个小点，首先是接口，就是光驱那个接口最好是sata3接口的; 然后是bios里有个地方IDE要设置成 AHCI模式。 装好之后可以下载一些测试工具，这里我忘了我用的啥了，查一下就知道。 安装Ubuntu系统我用的是u盘作为启动盘，所以这里就讲讲这种方式。 首先下载ubuntu系统iso， 然后用UltraISO制作启动盘，制作好后，保持u盘插入的状态，重启电脑，这时候要进入BIOS系统(具体按哪个键可以搜一下，我的华硕是F2)，在BIOS中更改启动盘，选择刚刚的u盘，应该会有名字的。 启动之后应该就是安装的界面了，具体安装过程怎么选择我也忘了，这里没有截图，捡我记得的写。我在安装过程中，提示过我一个东西，好像是有个格式不对，我选择的跳过还是什么的，反正不是确认。我那时候出现这个问题，就去google了，说是启动盘要用一个别的软件做才行，然后我信了他的邪，重新一边还是这样。后边再有印象的就是分区了。 首先说明一点，分区分区，分的是你电脑里，没有进行过初始化的区域，当你的ssd刚安电脑里的时候，你用硬盘管理看到这块磁盘是未分配状态的，那么在安装系统过程中就会使用这些未分配的区域。 Linux分区，应该是安装系统中比较重要的一点？我也是按照网上的一般教程进行分区的，分了四个区: /, /boot, /home, /swap， 另外在分区时，需要注意的是swap分区需要选择”交换空间”，其他三个就按默认的Ext4日志文件系统。在说一下这四个分区的含义：/，主分区相当于windows的c盘; /boot 引导分区; /home 用户存储数据用，需要大一点; /swap 相当于电脑的内存，设置为内存的1.5～2倍。分区设置完毕后，下方还有一项“安装启动引导器的设备”，默认是ubuntu引导windows，也就是开机启动显示的ubuntu的样子，然后选择是ubuntu还是window，如果想windows引导ubuntu，则“引导器的设备”选择之前/boot分区的名字。 实现双系统前面的说明了，我是从windows引导ubuntu的，所以还需要一些工具来设置ubuntu的启动选项，这里我用的是EasyBCD，打开easyBCD，选择add new entry，选择linux/BSD，name那里填Ubuntu（可自行填写）。device(驱动器)这一栏选择我们刚创建的“/boot”分区（200MB那个，可能大小会有一点出入）。最后点击Add entry（添加条目）。最后还有一点可能会出错的地方，就是设置了引导后，选择ubuntu却无法正常启动，具体原因我不记得了，应该是在新建ubuntu条目时有个选项有问题，具体是什么，我后面在看看。 好了，大概就是这样了，有很多东西没有讲清楚，因为google一下总会有讲的清楚的，我在这里也只是理了一下我做这些事情的一个过程，就是一个简单的思路。]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>ssd</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
</search>
